Overall Structure:
C# code can only see other code written within the same class by default.

Functions
First, the function must be placed outside of the Main function, but still inside the Program class.
C# does not support embedding of functions so the new function we add must be separate.
    Once built however the new function can be run by calling its name inside the Main 
    function and passing in the necessary input.

Public vs Private
Public functions are avaiable to any part of the program that can see it.
Private can only be called from within the same scope as the definition. 

Static
Static function can be called within the scope of its definition or by calling it on the class it's defined in.
A non-static method has to be called on an instance of an object. 

Void
Void is a keyword that signifies that the function has no return. 
If we want to return something, put the type there.

Object Oriented Programing

Classes define what objects we can build, how we can interact with 
them, and how they themselves interact with our program
Constructors are functions that exist to "construct" instances of a class.
A constructor is called the moment an object is created using the new keyword.

Abstract classes
Are simply classes that will never be instantiated. Think of them as classes specifically for inheritable characteristics.

S.O.L.I.D.
Single Responsibility Classes => Class should have one job
Open/Closed Extension => Make classes that are easy to subclass without changing the original class
Liskov Substitution => Subclasses should be capable of being treated like base classes
Interface Segregation => Don't have properties on classes that are unnecessary. Use Interfaces instead.
Dependency Inversion => Make code that is less reliant on other code

Interfacing:
Simply a requirements lists that is implemented on each class that belongs to that Interface.
This means each class must define those methods and fields within itself.
Multiple Interfaces can be implemented, with this be sure to define inheritance first.
    public classs Ostritch: Bird, CanRun => (Inheritance), (Interface)

Linq Methods: Language Integrated Query can be run on anything that is Ienumerable

Sidebar:
T is like any arg as arg
<T> as a parameter means accept any collection of items and return
that collection of items.

Get Set OOP

private _numPassengers = 5;
public int numPassengers {
 get { return _numPassengers }
 set { _numPassengers = value; }
}

Inheritance
protected will be hidden and still inherited
private will be hidden and not inherited
public is available to program and inheritable

Checks memory location:
A.Equals(B) with A and B being the respective variables

String interpolation
Console.WriteLine($"The value of 2 + 2 is {1+3}")

Type Conversion
Explicit casting:
    int num = 2;
    float numAsFloat = (float)num
    // Value equals 2.0
Explicit casting with built method: 
    int num = 2;
    string numToString = num.ToString();
    //Value equals "2"

Dictionaries
 The type of both the key and the value stored at that key must be 
 specified when initializing a dictionary as such: Dictionary<TKey, TValue>
  What type inference does is allows you to not have to directly type the type 
  for the variable, but rather will cause the variable to INFER what the type will 
  be based on the very first value assigned to it

 Dictionary<string,string> profile = new Dictionary<string,string>();

 foreach (KeyValuePair<string,string> entry in profile)
{
 Console.WriteLine(entry.Key + " - " + entry.Value);
}

Persisting Data MVC:
ViewBag.variableName = "Variable";
front end=> @ViewBag.variableName

Requires Session =>
Temp Data is for passing data from one method to another method
NOT FRONTEND
TempData["VariableName"] = "Variable";
another route => TempData["VariableName"];

HttpContext.Session.setString(key, value);
HttpContext.Session.getString(key, value);

HttpContext.Session.SetInt32(key, int);
HttpContext.Session.GetInt32(key, int);

